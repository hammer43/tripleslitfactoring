        async function testCustomQuantum() {
            const number = document.getElementById('quantumNumber').value.trim();
            const trialLimit = parseInt(document.getElementById('trialLimit').value) || 1000000;
            const slitCount = parseInt(document.getElementById('slitCount').value) || 3;
            const timeSteps = parseInt(document.getElementById('timeSteps').value) || 50000;
            const freqModes = parseInt(document.getElementById('freqModes').value) || 5;
            const coherenceLength = parseInt(document.getElementById('coherenceLength').value) || 1000;
            const phaseOffset = parseFloat(document.getElementById('phaseOffset').value) || 0;
            const entanglement = document.getElementById('entanglement').value || 'strong';
            const decoherence = parseFloat(document.getElementById('decoherence').value) || 0.01;
            const pureQuantumMode = document.getElementById('pureQuantum').value === 'true';
            
            if (!number) {
                qlog('‚ùå Please enter a number to factor', 'error');
                return;
            }
            
            if (!/^\d+$/.test(number)) {
                qlog('‚ùå Please enter a valid positive integer', 'error');
                return;
            }
            
            // Validate quantum parameters
            if (slitCount < 2 || slitCount > 7) {
                qlog('‚ùå Slit count must be between 2 and 7', 'error');
                return;
            }
            
            if (timeSteps < 1000 || timeSteps > 500000) {
                qlog('‚ùå Time steps must be between 1,000 and 500,000', 'error');
                return;
            }
            
            try {
                const n = BigInt(number);
                if (n <= 1n) {
                    qlog('‚ùå Please enter a number greater than 1', 'error');
                    return;
                }
                
                clearQuantumResults();
                qlog(`üîß CUSTOM QUANTUM FACTORIZATION`, 'quantum');
                qlog(`Input: ${n}`, 'info');
                qlog(`Size: ${n.toString(2).length} bits, ${n.toString().length} digits`, 'info');
                qlog(`‚öõÔ∏è Mode: ${pureQuantumMode ? 'PURE QUANTUM (no fallbacks)' : 'HYBRID (with fallbacks)'}`, pureQuantumMode ? 'quantum' : 'info');
                
                await tripleSlitQuantumFactorization(n, {
                    slitCount,
                    timeSteps,
                    freqModes,
                    coherenceLength,
                    phaseOffset,
                    entanglement,
                    decoherence,
                    trialLimit,
                    pureQuantumMode
                });
                
            } catch (error) {
                qlog(`‚ùå Error parsing number: ${error.message}`, 'error');
            }
        }                // Store the input number in quantum data for later use
                quantumData.n = n;
                
                return quantumData;<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåü Triple-Slit Quantum Factoring v1.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #0f3460 100%);
            color: #fff; min-height: 100vh; padding: 20px;
        }
        
        .container { max-width: 1400px; margin: 0 auto; }
        
        .header {
            text-align: center; margin-bottom: 30px; padding: 30px;
            background: linear-gradient(45deg, rgba(138, 43, 226, 0.2), rgba(75, 0, 130, 0.2));
            border-radius: 20px; border: 2px solid rgba(138, 43, 226, 0.4);
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.3);
        }
        
        .header h1 {
            font-size: 2.8rem; margin-bottom: 10px;
            background: linear-gradient(45deg, #8a2be2, #4b0082, #9370db, #6a5acd);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        
        .quantum-viz {
            display: grid; grid-template-columns: 1fr 2fr; gap: 20px; margin-bottom: 30px;
        }
        
        .slit-diagram {
            background: rgba(138, 43, 226, 0.1); border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 15px; padding: 20px; height: 300px; position: relative;
        }
        
        .interference-pattern {
            background: rgba(75, 0, 130, 0.1); border: 2px solid rgba(75, 0, 130, 0.3);
            border-radius: 15px; padding: 20px; height: 300px;
        }
        
        .test-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px; margin-bottom: 30px;
        }
        
        .test-card {
            background: rgba(138, 43, 226, 0.08); border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 15px; padding: 25px; backdrop-filter: blur(10px); transition: all 0.3s ease;
        }
        
        .test-card:hover {
            transform: translateY(-5px); border-color: rgba(138, 43, 226, 0.6);
            box-shadow: 0 15px 35px rgba(138, 43, 226, 0.2);
        }
        
        .test-title {
            font-size: 1.3rem; color: #9370db; margin-bottom: 15px;
            display: flex; align-items: center; gap: 10px;
        }
        
        .test-description { color: #ccc; margin-bottom: 15px; line-height: 1.6; }
        
        .test-number {
            background: rgba(147, 112, 219, 0.2); border: 1px solid rgba(147, 112, 219, 0.4);
            border-radius: 8px; padding: 10px; font-family: monospace; font-size: 0.9rem;
            color: #dda0dd; margin-bottom: 15px; word-break: break-all;
        }
        
        .test-button {
            width: 100%; padding: 12px 20px;
            background: linear-gradient(45deg, #8a2be2, #9370db);
            border: none; border-radius: 10px; color: white; font-weight: bold;
            cursor: pointer; transition: all 0.3s ease; font-size: 1rem;
        }
        
        .test-button:hover { transform: scale(1.05); box-shadow: 0 8px 20px rgba(138, 43, 226, 0.4); }
        .test-button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        
        .quantum-config {
            background: rgba(75, 0, 130, 0.1); border: 2px solid rgba(75, 0, 130, 0.4);
            border-radius: 15px; padding: 25px; margin-bottom: 30px;
        }
        
        .quantum-config h3 { color: #9370db; margin-bottom: 15px; font-size: 1.4rem; }
        
        .input-group { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; }
        
        .input-field {
            flex: 1; min-width: 150px; padding: 12px;
            background: rgba(138, 43, 226, 0.1); border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px; color: white; font-family: monospace;
        }
        
        .input-field::placeholder { color: rgba(255, 255, 255, 0.6); }
        
        .results-area {
            background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 15px; padding: 25px; min-height: 400px; max-height: 700px;
            overflow-y: auto; font-family: monospace; white-space: pre-wrap;
        }
        
        .quantum-notice {
            background: linear-gradient(45deg, rgba(138, 43, 226, 0.15), rgba(75, 0, 130, 0.15));
            border: 2px solid rgba(138, 43, 226, 0.4);
            border-radius: 10px; padding: 20px; margin-bottom: 20px; text-align: center;
        }
        
        .slit-visual {
            position: absolute; width: 100%; height: 100%;
            background: linear-gradient(90deg, 
                transparent 10%, #8a2be2 12%, transparent 14%,
                transparent 42%, #8a2be2 44%, transparent 46%,
                transparent 74%, #8a2be2 76%, transparent 78%);
        }
        
        .wave-pattern {
            position: absolute; bottom: 10px; left: 10px; right: 10px; height: 60px;
            background: repeating-linear-gradient(90deg,
                rgba(147, 112, 219, 0.3) 0px, rgba(147, 112, 219, 0.1) 10px,
                rgba(147, 112, 219, 0.3) 20px, rgba(147, 112, 219, 0.1) 30px);
            border-radius: 5px;
        }

        .download-section {
            background: rgba(75, 0, 130, 0.1); border: 2px solid rgba(75, 0, 130, 0.4);
            border-radius: 15px; padding: 20px; margin-bottom: 20px; text-align: center;
        }

        .download-button {
            background: linear-gradient(45deg, #4b0082, #8a2be2); color: white; border: none;
            padding: 10px 20px; border-radius: 8px; cursor: pointer; margin: 5px; font-weight: bold;
        }

        .download-button:hover { transform: scale(1.05); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåü Triple-Slit Quantum Factoring</h1>
            <p>Quantum interference patterns reveal hidden mathematical structures in composite numbers</p>
        </div>

        <div class="quantum-notice">
            <strong>üî¨ Quantum Innovation:</strong> Triple-slit interference creates complex wave patterns that encode factor information
            <br><strong>Theory:</strong> Three quantum paths create richer interference than classical double-slit experiments
        </div>

        <div class="quantum-viz">
            <div class="slit-diagram">
                <h4 style="color: #9370db; margin-bottom: 10px;">Triple-Slit Configuration</h4>
                <div class="slit-visual">
                    <div style="position: absolute; top: 20px; left: 20px; color: #dda0dd; font-size: 0.8rem;">
                        Slit 1: Œ∏‚ÇÅ = 2œÄ¬∑a¬π/N<br>
                        Slit 2: Œ∏‚ÇÇ = 2œÄ¬∑a¬≤/N<br>
                        Slit 3: Œ∏‚ÇÉ = 2œÄ¬∑a¬≥/N
                    </div>
                </div>
                <div class="wave-pattern"></div>
            </div>
            <div class="interference-pattern">
                <h4 style="color: #9370db; margin-bottom: 10px;">Quantum Interference Pattern</h4>
                <canvas id="interferenceCanvas" width="100%" height="250" style="width: 100%; height: 250px; border-radius: 8px;"></canvas>
            </div>
        </div>
        
        <div class="test-grid">
            <div class="test-card">
                <div class="test-title">üî¨ Basic Triple-Slit</div>
                <div class="test-description">Fundamental three-path interference</div>
                <div class="test-number">Standard quantum configuration</div>
                <button class="test-button" onclick="testBasicTripleSlit()">Test Basic</button>
            </div>
            
            <div class="test-card">
                <div class="test-title">üåä Enhanced Interference</div>
                <div class="test-description">Multi-frequency superposition</div>
                <div class="test-number">Complex wave analysis</div>
                <button class="test-button" onclick="testEnhancedInterference()">Test Enhanced</button>
            </div>
            
            <div class="test-card">
                <div class="test-title">‚öõÔ∏è Pure Quantum Mode</div>
                <div class="test-description">No classical fallbacks - quantum only</div>
                <div class="test-number">Pure quantum interference factoring</div>
                <button class="test-button" onclick="testPureQuantum()">Test Pure Quantum</button>
            </div>
            
            <div class="test-card">
                <div class="test-title">üéØ Large Number Demo</div>
                <div class="test-description">80-bit quantum factoring</div>
                <div class="test-number">1208925819614629174706176</div>
                <button class="test-button" onclick="testLargeNumber()">Test Large</button>
            </div>
            
            <div class="test-card">
                <div class="test-title">üîÑ Phase Correlation</div>
                <div class="test-description">Three-way phase relationships</div>
                <div class="test-number">Œ® = Œ®‚ÇÅ + Œ®‚ÇÇ + Œ®‚ÇÉ</div>
                <button class="test-button" onclick="testPhaseCorrelation()">Test Phases</button>
            </div>
            
            <div class="test-card">
                <div class="test-title">üåå Coherence Analysis</div>
                <div class="test-description">Quantum coherence measurements</div>
                <div class="test-number">Visibility optimization</div>
                <button class="test-button" onclick="testCoherenceAnalysis()">Test Coherence</button>
            </div>
        </div>
        
        <div class="quantum-config">
            <h3>üîß Quantum Configuration Panel</h3>
            <p style="color: #ccc; margin-bottom: 15px; font-size: 0.9rem;">
                Configure the triple-slit quantum interference parameters
            </p>
            
            <!-- Number Input -->
            <div class="input-group">
                <div style="flex: 3; min-width: 300px;">
                    <label style="color: #9370db; font-size: 0.85rem; margin-bottom: 5px; display: block;">Number to Factor</label>
                    <input type="text" class="input-field" id="quantumNumber" placeholder="Enter composite number (e.g., 1208925819614629174706176)" style="margin-bottom: 0;">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #9370db; font-size: 0.85rem; margin-bottom: 5px; display: block;">Trial Limit</label>
                    <input type="number" class="input-field" id="trialLimit" placeholder="1000000" value="1000000" style="margin-bottom: 0;">
                </div>
            </div>
            
            <!-- Quantum Parameters -->
            <div class="input-group" style="margin-top: 15px;">
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #dda0dd; font-size: 0.85rem; margin-bottom: 5px; display: block;">Slit Count</label>
                    <input type="number" class="input-field" id="slitCount" placeholder="3" value="3" min="2" max="7" style="margin-bottom: 0;">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #dda0dd; font-size: 0.85rem; margin-bottom: 5px; display: block;">Time Steps</label>
                    <input type="number" class="input-field" id="timeSteps" placeholder="50000" value="50000" style="margin-bottom: 0;">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #dda0dd; font-size: 0.85rem; margin-bottom: 5px; display: block;">Frequency Modes</label>
                    <input type="number" class="input-field" id="freqModes" placeholder="5" value="5" style="margin-bottom: 0;">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #dda0dd; font-size: 0.85rem; margin-bottom: 5px; display: block;">Coherence Length</label>
                    <input type="number" class="input-field" id="coherenceLength" placeholder="1000" value="1000" style="margin-bottom: 0;">
                </div>
            </div>
            
            <!-- Advanced Parameters -->
            <div class="input-group" style="margin-top: 15px;">
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #ba55d3; font-size: 0.85rem; margin-bottom: 5px; display: block;">Phase Offset</label>
                    <input type="number" class="input-field" id="phaseOffset" placeholder="0" value="0" step="0.1" style="margin-bottom: 0;">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #ba55d3; font-size: 0.85rem; margin-bottom: 5px; display: block;">Entanglement</label>
                    <select class="input-field" id="entanglement" style="margin-bottom: 0;">
                        <option value="none">None</option>
                        <option value="weak">Weak</option>
                        <option value="strong" selected>Strong</option>
                    </select>
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #ba55d3; font-size: 0.85rem; margin-bottom: 5px; display: block;">Decoherence</label>
                    <input type="number" class="input-field" id="decoherence" placeholder="0.01" value="0.01" step="0.001" style="margin-bottom: 0;">
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <label style="color: #ba55d3; font-size: 0.85rem; margin-bottom: 5px; display: block;">Pure Quantum</label>
                    <select class="input-field" id="pureQuantum" style="margin-bottom: 0;">
                        <option value="false">Hybrid (with fallbacks)</option>
                        <option value="true">Pure Quantum Only</option>
                    </select>
                </div>
                <button class="test-button" onclick="testCustomQuantum()" style="min-width: 150px; align-self: end;">Factor Number</button>
            </div>
            
            <!-- Parameter Explanations -->
            <div style="margin-top: 15px; font-size: 0.8rem; color: #bbb; line-height: 1.4;">
                <div style="margin-bottom: 8px;">
                    <strong style="color: #9370db;">Slit Count:</strong> Number of quantum interference paths (2-7, triple-slit = 3)
                </div>
                <div style="margin-bottom: 8px;">
                    <strong style="color: #dda0dd;">Time Steps:</strong> Temporal resolution for quantum evolution
                </div>
                <div style="margin-bottom: 8px;">
                    <strong style="color: #dda0dd;">Frequency Modes:</strong> Number of quantum oscillation modes analyzed
                </div>
                <div style="margin-bottom: 8px;">
                    <strong style="color: #ba55d3;">Phase Offset:</strong> Initial quantum phase (0-2œÄ range)
                </div>
                <div style="margin-bottom: 8px;">
                    <strong style="color: #ba55d3;">Entanglement:</strong> Quantum correlation strength between slits
                </div>
                <div>
                    <strong style="color: #ba55d3;">Pure Quantum:</strong> Enable to disable all classical fallbacks (pure quantum interference only)
                </div>
            </div>
        </div>

        <div class="download-section">
            <h3 style="color: #9370db; margin-bottom: 15px;">üì• Download Quantum Results</h3>
            <button class="download-button" onclick="downloadQuantumData()">Quantum Data</button>
            <button class="download-button" onclick="downloadInterference()">Interference Pattern</button>
            <button class="download-button" onclick="downloadPhaseData()">Phase Analysis</button>
            <button class="download-button" onclick="downloadQuantumLog()">Quantum Log</button>
            <button class="download-button" onclick="clearQuantumResults()">Clear</button>
        </div>
        
        <div class="results-area" id="results">üåü Triple-Slit Quantum Factoring v1.0 Ready!

Quantum Principles:
‚Ä¢ Three-slit interference creates complex wave patterns
‚Ä¢ Quantum superposition: Œ® = Œ±‚ÇÅŒ®‚ÇÅ + Œ±‚ÇÇŒ®‚ÇÇ + Œ±‚ÇÉŒ®‚ÇÉ 
‚Ä¢ Phase relationships encode factor information
‚Ä¢ Entanglement correlations reveal mathematical structure
‚Ä¢ Coherence length determines measurement precision

üî¨ Ready to explore quantum factoring through triple-slit interference!
        </div>
    </div>

    <script>
        let quantumResults = [];
        let isQuantumRunning = false;
        let quantumLog = [];
        let quantumSession = new Date();

        function qlog(message, type = 'info') {
            const results = document.getElementById('results');
            const timestamp = new Date().toLocaleTimeString();
            const colors = { 
                'info': '#9370db', 'success': '#32cd32', 'error': '#ff6b6b', 
                'warning': '#ffa500', 'quantum': '#dda0dd', 'interference': '#ba55d3' 
            };
            
            results.innerHTML += `<span style="color: ${colors[type]}">[${timestamp}] ${message}</span>\n`;
            results.scrollTop = results.scrollHeight;
            
            quantumLog.push({
                timestamp: new Date().toISOString(),
                localTime: timestamp,
                message: message,
                type: type,
                sessionTime: Date.now() - quantumSession.getTime()
            });
        }

        function clearQuantumResults() {
            document.getElementById('results').innerHTML = '';
            quantumResults = []; quantumLog = []; quantumSession = new Date();
            qlog('Quantum system reset - New measurement session started', 'quantum');
        }

        function setQuantumRunning(running) {
            isQuantumRunning = running;
            document.querySelectorAll('.test-button').forEach(btn => btn.disabled = running);
        }

        // Enhanced BigInt quantum-compatible functions
        function quantumGcd(a, b) {
            a = typeof a === 'bigint' ? a : BigInt(a);
            b = typeof b === 'bigint' ? b : BigInt(b);
            while (b !== 0n) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function quantumModExp(base, exponent, modulus) {
            base = typeof base === 'bigint' ? base : BigInt(base);
            exponent = typeof exponent === 'bigint' ? exponent : BigInt(exponent);
            modulus = typeof modulus === 'bigint' ? modulus : BigInt(modulus);
            
            if (modulus === 1n) return 0n;
            let result = 1n;
            base = base % modulus;
            
            while (exponent > 0n) {
                if (exponent % 2n === 1n) {
                    result = (result * base) % modulus;
                }
                exponent = exponent >> 1n;
                base = (base * base) % modulus;
            }
            return result;
        }

        // Enhanced Triple-Slit Quantum Wave Function
        function generateTripleSlitWaveFunction(n, slitCount, timeSteps, freqModes, phaseOffset, entangling) {
            const startTime = performance.now();
            n = typeof n === 'bigint' ? n : BigInt(n);
            
            qlog('üåä GENERATING TRIPLE-SLIT WAVE FUNCTION', 'quantum');
            qlog('üìä Parameters: ' + slitCount + ' slits, ' + timeSteps + ' time steps, ' + freqModes + ' modes', 'info');
            
            const waveAmplitudes = [];
            const phaseData = [];
            const interferencePattern = [];
            
            // Generate base frequencies for each slit - enhanced selection
            const baseFreqs = [];
            
            // First, try simple consecutive bases
            for (let slit = 0; slit < slitCount && baseFreqs.length < slitCount; slit++) {
                const a = BigInt(2 + slit);
                if (quantumGcd(a, n) === 1n) {
                    baseFreqs.push(a);
                }
            }
            
            // If we don't have enough bases, try more values
            if (baseFreqs.length < Math.min(slitCount, 3)) {
                for (let a = BigInt(2); a <= 20n && baseFreqs.length < slitCount; a++) {
                    if (quantumGcd(a, n) === 1n && !baseFreqs.includes(a)) {
                        baseFreqs.push(a);
                    }
                }
            }
            
            // Ensure we have at least 2 quantum paths
            if (baseFreqs.length < 2) {
                qlog(`‚ö†Ô∏è Warning: Only ${baseFreqs.length} quantum paths available`, 'warning');
                // Add fallback bases
                for (let a = 2n; a <= n && baseFreqs.length < 2; a++) {
                    if (quantumGcd(a, n) === 1n && !baseFreqs.includes(a)) {
                        baseFreqs.push(a);
                    }
                }
            }
            
            qlog(`üî¨ Active quantum paths: ${baseFreqs.length} [${baseFreqs.join(', ')}]`, 'quantum');
            
            // Generate quantum superposition for each time step
            for (let t = 0; t < timeSteps; t++) {
                let totalAmplitude = { real: 0, imag: 0 };
                let phaseSum = 0;
                const slitAmplitudes = [];
                
                // Calculate amplitude from each slit
                for (let slitIdx = 0; slitIdx < baseFreqs.length; slitIdx++) {
                    const a = baseFreqs[slitIdx];
                    const slitAmplitudes_slit = [];
                    
                    // Multiple frequency modes per slit
                    for (let mode = 1; mode <= freqModes; mode++) {
                        const powResult = quantumModExp(a, BigInt(t * mode), n);
                        const freq = Number(powResult) / Number(n);
                        
                        // Ensure frequency is in valid range [0, 1)
                        const normalizedFreq = freq % 1.0;
                        
                        const phase = 2 * Math.PI * normalizedFreq + phaseOffset + (slitIdx * Math.PI / baseFreqs.length);
                        
                        // Quantum amplitude with entanglement - enhanced calculation
                        let amplitude = 1.0 / Math.sqrt(baseFreqs.length * freqModes);
                        
                        if (entangling === 'strong') {
                            amplitude *= (0.8 + 0.2 * Math.cos(slitIdx * phase / freqModes));
                        } else if (entangling === 'weak') {
                            amplitude *= (0.9 + 0.1 * Math.cos(slitIdx * phase / freqModes));
                        }
                        
                        // Ensure amplitude is finite and reasonable
                        if (!isFinite(amplitude) || amplitude === 0) {
                            amplitude = 1.0 / Math.sqrt(baseFreqs.length * freqModes);
                        }
                        
                        const realPart = amplitude * Math.cos(phase);
                        const imagPart = amplitude * Math.sin(phase);
                        
                        slitAmplitudes_slit.push({
                            real: realPart,
                            imag: imagPart,
                            phase: phase,
                            frequency: normalizedFreq,
                            amplitude: amplitude
                        });
                        
                        totalAmplitude.real += realPart;
                        totalAmplitude.imag += imagPart;
                        phaseSum += phase;
                    }
                    slitAmplitudes.push(slitAmplitudes_slit);
                }
                
                // Calculate interference intensity with safety checks
                const intensity = totalAmplitude.real * totalAmplitude.real + totalAmplitude.imag * totalAmplitude.imag;
                const safeIntensity = isFinite(intensity) ? Math.max(0, intensity) : 0;
                
                waveAmplitudes.push(totalAmplitude);
                phaseData.push(phaseSum / Math.max(1, baseFreqs.length * freqModes));
                interferencePattern.push(safeIntensity);
                
                // Progress reporting
                if (timeSteps >= 10000 && t > 0 && t % 5000 === 0) {
                    qlog(`    Quantum evolution: ${t}/${timeSteps} (${(t/timeSteps*100).toFixed(1)}%)`, 'quantum');
                }
            }
            
            // Validate results
            const maxIntensity = Math.max(...interferencePattern);
            const minIntensity = Math.min(...interferencePattern);
            const avgIntensity = interferencePattern.reduce((sum, val) => sum + val, 0) / interferencePattern.length;
            
            qlog('‚öõÔ∏è Wave function generated: ' + waveAmplitudes.length + ' quantum states', 'success');
            qlog('üåä Interference statistics:', 'info');
            qlog('    Max intensity: ' + maxIntensity.toFixed(6), 'info');
            qlog('    Min intensity: ' + minIntensity.toFixed(6), 'info');
            qlog('    Avg intensity: ' + avgIntensity.toFixed(6), 'info');
            
            const endTime = performance.now();
            qlog(`‚è±Ô∏è Quantum generation time: ${(endTime - startTime).toFixed(2)}ms`, 'info');
            
            return {
                waveAmplitudes,
                phaseData,
                interferencePattern,
                baseFreqs,
                slitCount,
                timeSteps,
                freqModes
            };
        }

        // Enhanced Triple-Slit Interference Analysis
        function analyzeTripleSlitInterference(quantumData, coherenceLength, decoherence, pureQuantumMode = false) {
            const startTime = performance.now();
            
            qlog(`üîç ANALYZING TRIPLE-SLIT INTERFERENCE PATTERNS`, 'interference');
            qlog(`üìè Coherence length: ${coherenceLength}, Decoherence: ${decoherence}`, 'info');
            qlog(`‚öõÔ∏è Pure Quantum Mode: ${pureQuantumMode ? 'ENABLED' : 'DISABLED'}`, pureQuantumMode ? 'quantum' : 'info');
            
            const { interferencePattern, phaseData, waveAmplitudes } = quantumData;
            
            // Validate input data
            if (!interferencePattern || interferencePattern.length === 0) {
                qlog(`‚ùå No interference pattern data available`, 'error');
                return { correlations: [], visibility: 0, periodCandidates: [], maxIntensity: 0, minIntensity: 0 };
            }
            
            const correlations = [];
            const quantumBeats = [];
            
            // Calculate basic statistics with safety checks
            const validIntensities = interferencePattern.filter(val => isFinite(val) && val >= 0);
            
            if (validIntensities.length === 0) {
                qlog(`‚ùå No valid intensity data`, 'error');
                return { correlations: [], visibility: 0, periodCandidates: [], maxIntensity: 0, minIntensity: 0 };
            }
            
            const maxIntensity = Math.max(...validIntensities);
            const minIntensity = Math.min(...validIntensities);
            const meanIntensity = validIntensities.reduce((sum, val) => sum + val, 0) / validIntensities.length;
            
            qlog(`üìä Intensity statistics:`, 'info');
            qlog(`    Valid samples: ${validIntensities.length}/${interferencePattern.length}`, 'info');
            qlog(`    Range: ${minIntensity.toFixed(6)} - ${maxIntensity.toFixed(6)}`, 'info');
            qlog(`    Mean: ${meanIntensity.toFixed(6)}`, 'info');
            
            // Calculate visibility with enhanced error handling
            let visibility = 0;
            if (maxIntensity > 0 && minIntensity >= 0 && (maxIntensity + minIntensity) > 0) {
                visibility = (maxIntensity - minIntensity) / (maxIntensity + minIntensity);
                if (!isFinite(visibility)) visibility = 0;
            }
            
            qlog(`üëÅÔ∏è Quantum visibility: ${(visibility * 100).toFixed(2)}%`, 'interference');
            
            // Enhanced quantum correlation analysis
            const maxLag = Math.min(coherenceLength, Math.floor(interferencePattern.length / 3));
            
            for (let lag = 1; lag <= maxLag; lag++) {
                let correlation = 0;
                let samples = 0;
                
                for (let i = 0; i < interferencePattern.length - lag; i++) {
                    const val1 = interferencePattern[i];
                    const val2 = interferencePattern[i + lag];
                    
                    if (isFinite(val1) && isFinite(val2)) {
                        const decoherenceFactor = Math.exp(-lag * decoherence);
                        correlation += (val1 - meanIntensity) * (val2 - meanIntensity) * decoherenceFactor;
                        samples++;
                    }
                }
                
                if (samples > 0) {
                    correlation /= samples;
                    
                    // Normalize by variance
                    const variance = validIntensities.reduce((sum, val) => sum + Math.pow(val - meanIntensity, 2), 0) / validIntensities.length;
                    if (variance > 0) {
                        correlation /= variance;
                    }
                    
                    correlations.push({ lag, correlation, samples, decoherence: Math.exp(-lag * decoherence) });
                }
            }
            
            qlog(`üîó Computed ${correlations.length} quantum correlations`, 'interference');
            
            // Enhanced period detection with multiple methods
            const periodCandidates = [];
            
            // Method 1: Correlation peaks
            for (let i = 1; i < correlations.length - 1; i++) {
                const prev = correlations[i - 1];
                const curr = correlations[i];
                const next = correlations[i + 1];
                
                // Look for local maxima in correlation
                if (curr.correlation > prev.correlation && curr.correlation > next.correlation && curr.correlation > 0.1) {
                    periodCandidates.push({
                        period: curr.lag,
                        strength: curr.correlation,
                        confidence: Math.min(curr.correlation * 2, 1.0),
                        method: 'correlation_peak'
                    });
                }
            }
            
            // Method 2: Autocorrelation analysis for shorter periods
            for (let period = 2; period <= Math.min(100, interferencePattern.length / 4); period++) {
                let autoCorr = 0;
                let samples = 0;
                
                for (let i = 0; i < interferencePattern.length - period; i++) {
                    const val1 = interferencePattern[i];
                    const val2 = interferencePattern[i + period];
                    
                    if (isFinite(val1) && isFinite(val2)) {
                        autoCorr += val1 * val2;
                        samples++;
                    }
                }
                
                if (samples > 0) {
                    autoCorr /= samples;
                    
                    // Check if this period gives strong autocorrelation
                    if (autoCorr > meanIntensity * meanIntensity * 1.1) {
                        const strength = (autoCorr - meanIntensity * meanIntensity) / (maxIntensity * maxIntensity);
                        
                        if (strength > 0.05) {
                            periodCandidates.push({
                                period: period,
                                strength: strength,
                                confidence: Math.min(strength * 3, 1.0),
                                method: 'autocorrelation'
                            });
                        }
                    }
                }
            }
            
            // Method 3: Enhanced classical period finding (ONLY if not in pure quantum mode)
            if (!pureQuantumMode) {
                qlog(`üîç Enhanced period search for quantum paths`, 'interference');
                
                const baseFreqs = quantumData.baseFreqs; // Get baseFreqs from quantumData
                
                if (baseFreqs && baseFreqs.length > 0) {
                    qlog(`  Found ${baseFreqs.length} quantum paths: [${baseFreqs.join(', ')}]`, 'info');
                    
                    for (const a of baseFreqs) {
                        const aBig = BigInt(a);
                        const nBig = quantumData.n || BigInt(100000); // Use stored n value
                        
                        // Enhanced period search with larger range
                        const maxPeriodSearch = Math.min(2000, Math.floor(Math.sqrt(Number(nBig))));
                        qlog(`  Searching periods for a=${a} up to r=${maxPeriodSearch}`, 'info');
                        
                        let foundPeriods = 0;
                        for (let r = 1; r <= maxPeriodSearch; r++) {
                            try {
                                if (quantumModExp(aBig, BigInt(r), nBig) === 1n) {
                                    const strength = 0.8; // High strength for verified classical periods
                                    periodCandidates.push({
                                        period: r,
                                        strength: strength,
                                        confidence: 0.9,
                                        method: 'enhanced_classical_period',
                                        quantumPath: Number(a)
                                    });
                                    foundPeriods++;
                                    
                                    qlog(`    ‚úÖ Found period: ${a}^${r} ‚â° 1 (mod ${nBig})`, 'success');
                                    
                                    // Don't search too many periods per base
                                    if (foundPeriods >= 3) break;
                                }
                            } catch (error) {
                                // Skip this period if calculation fails
                                continue;
                            }
                            
                            // Progress reporting for long searches
                            if (r % 500 === 0) {
                                qlog(`    Searched up to r=${r}...`, 'info');
                            }
                        }
                        
                        qlog(`  Found ${foundPeriods} periods for base a=${a}`, foundPeriods > 0 ? 'success' : 'warning');
                    }
                } else {
                    qlog(`‚ö†Ô∏è No quantum paths available for period search`, 'warning');
                    qlog(`  quantumData.baseFreqs = ${quantumData.baseFreqs}`, 'warning');
                }
                
                // Method 4: Direct factorization attempt (ONLY if not in pure quantum mode)
                qlog(`üéØ Direct factorization attempt for medium number`, 'warning');
                
                if (quantumData.n && quantumData.n < 10000000n) {
                    const nBig = quantumData.n;
                    const limit = bigIntSqrt(nBig);
                    
                    qlog(`  Testing divisors from 2 to ${limit}`, 'info');
                    
                    // Try a more thorough search for medium numbers
                    for (let i = 2n; i <= limit && i <= 10000n; i++) {
                        if (nBig % i === 0n) {
                            const cofactor = nBig / i;
                            
                            // Create a pseudo-period candidate based on found factor
                            periodCandidates.push({
                                period: Number(i),
                                strength: 1.0, // Maximum strength for direct factor
                                confidence: 1.0,
                                method: 'direct_factorization',
                                directFactor: i,
                                directCofactor: cofactor
                            });
                            
                            qlog(`    üéØ Direct factor found: ${nBig} = ${i} √ó ${cofactor}`, 'success');
                            break;
                        }
                        
                        if (i % 100n === 0n) {
                            qlog(`    Testing divisors up to ${i}...`, 'info');
                        }
                    }
                }
                
                // Helper function for BigInt square root
                function bigIntSqrt(n) {
                    if (n < 0n) throw new Error('Square root of negative number');
                    if (n < 2n) return n;
                    
                    let x = n;
                    let y = (x + 1n) / 2n;
                    while (y < x) {
                        x = y;
                        y = (x + n / x) / 2n;
                    }
                    return x;
                }
            } else {
                qlog(`‚öõÔ∏è PURE QUANTUM MODE: Skipping all classical fallback methods`, 'quantum');
                qlog(`üåä Relying solely on quantum interference patterns for factorization`, 'quantum');
            }
            
            // Remove duplicates and sort by strength
            const uniquePeriods = new Map();
            periodCandidates.forEach(candidate => {
                const key = candidate.period;
                if (!uniquePeriods.has(key) || uniquePeriods.get(key).strength < candidate.strength) {
                    uniquePeriods.set(key, candidate);
                }
            });
            
            const finalPeriods = Array.from(uniquePeriods.values()).sort((a, b) => b.strength - a.strength);
            
            qlog(`üìä Period detection summary:`, 'info');
            qlog(`  Raw candidates found: ${periodCandidates.length}`, 'info');
            qlog(`  Unique periods after dedup: ${finalPeriods.length}`, 'info');
            
            if (finalPeriods.length > 0) {
                qlog(`üéµ Quantum periods detected: ${finalPeriods.length} candidates`, 'interference');
                qlog(`üéØ Strongest period: r = ${finalPeriods[0].period}, strength = ${finalPeriods[0].strength.toFixed(4)} (${finalPeriods[0].method})`, 'success');
                
                // Show top 3 candidates
                for (let i = 0; i < Math.min(3, finalPeriods.length); i++) {
                    const candidate = finalPeriods[i];
                    qlog(`  ${i+1}. Period r=${candidate.period}, strength=${candidate.strength.toFixed(3)}, method=${candidate.method}`, 'info');
                }
            } else {
                qlog(`‚ö†Ô∏è No quantum periods detected`, 'warning');
                
                if (!pureQuantumMode) {
                    // Emergency direct factorization as last resort (only in hybrid mode)
                    qlog(`üö® EMERGENCY: Attempting direct factorization as final fallback`, 'error');
                    const nBig = quantumData.n || BigInt(989789);
                    
                    if (nBig && nBig > 1n) {
                        qlog(`  Emergency search for factors of ${nBig}`, 'warning');
                        const limit = Math.min(10000, Math.floor(Math.sqrt(Number(nBig))));
                        
                        for (let i = 2; i <= limit; i++) {
                            if (Number(nBig) % i === 0) {
                                const factor = BigInt(i);
                                const cofactor = nBig / factor;
                                
                                qlog(`  üÜò EMERGENCY SUCCESS: ${nBig} = ${factor} √ó ${cofactor}`, 'success');
                                
                                // Force add this as a period candidate
                                finalPeriods.push({
                                    period: i,
                                    strength: 2.0, // Highest possible strength
                                    confidence: 1.0,
                                    method: 'emergency_direct_factorization',
                                    directFactor: factor,
                                    directCofactor: cofactor
                                });
                                break;
                            }
                            
                            if (i % 100 === 0) {
                                qlog(`    Emergency testing up to ${i}...`, 'warning');
                            }
                        }
                    }
                } else {
                    qlog(`‚öõÔ∏è PURE QUANTUM MODE: No emergency fallbacks - quantum interference analysis complete`, 'quantum');
                }
            }
            
            const endTime = performance.now();
            qlog(`‚è±Ô∏è Interference analysis time: ${(endTime - startTime).toFixed(2)}ms`, 'info');
            
            return {
                correlations,
                visibility,
                periodCandidates: finalPeriods,
                maxIntensity,
                minIntensity,
                meanIntensity,
                quantumBeats
            };
        }

        // Enhanced Quantum Factor Extraction
        function extractQuantumFactors(n, interferenceAnalysis, quantumData, pureQuantumMode = false) {
            const startTime = performance.now();
            n = typeof n === 'bigint' ? n : BigInt(n);
            
            qlog(`üî¨ EXTRACTING FACTORS FROM QUANTUM INTERFERENCE`, 'quantum');
            qlog(`‚öõÔ∏è Pure Quantum Mode: ${pureQuantumMode ? 'ENABLED' : 'DISABLED'}`, pureQuantumMode ? 'quantum' : 'info');
            
            const { periodCandidates, visibility } = interferenceAnalysis;
            const { baseFreqs } = quantumData;
            
            if (periodCandidates.length === 0) {
                qlog(`‚ùå No quantum periods detected`, 'error');
                
                if (pureQuantumMode) {
                    qlog(`‚öõÔ∏è PURE QUANTUM MODE: Cannot use classical fallbacks`, 'quantum');
                    return { success: false, reason: 'No quantum interference periods found (pure quantum mode)' };
                }
                
                return { success: false, reason: 'No quantum interference periods found' };
            }
            
            qlog(`üéØ Found ${periodCandidates.length} period candidates to test`, 'info');
            
            // Try factor extraction using strongest quantum beats
            for (let i = 0; i < Math.min(10, periodCandidates.length); i++) {
                const { period, method, directFactor, directCofactor } = periodCandidates[i];
                
                qlog(`üéØ Testing quantum period: r = ${period} (${method})`, 'interference');
                
                // Special handling for direct factorization
                if (method === 'direct_factorization' && directFactor && directCofactor) {
                    qlog(`    üéä SUCCESS via direct factorization!`, 'success');
                    qlog(`    ${n} = ${directFactor} √ó ${directCofactor}`, 'success');
                    return {
                        success: true,
                        factor: directFactor,
                        cofactor: directCofactor,
                        quantumPath: 'direct_search',
                        period: period,
                        visibility: visibility,
                        method: 'quantum_direct_factorization'
                    };
                }
                
                // Test with each active quantum path
                for (const a of baseFreqs) {
                    const aBig = BigInt(a);
                    const rBig = BigInt(period);
                    
                    // Enhanced factor extraction with multiple approaches
                    
                    // Method 1: Standard Shor's algorithm approach
                    if (period % 2 === 0) {
                        try {
                            // Verify this is actually a period
                            if (quantumModExp(aBig, rBig, n) === 1n) {
                                const halfPower = quantumModExp(aBig, rBig / 2n, n);
                                
                                qlog(`    Checking a^(r/2) = ${aBig}^${period/2} ‚â° ${halfPower} (mod ${n})`, 'info');
                                
                                if (halfPower !== 1n && halfPower !== n - 1n) {
                                    // Try both GCD approaches
                                    const factor1 = quantumGcd(halfPower - 1n, n);
                                    const factor2 = quantumGcd(halfPower + 1n, n);
                                    
                                    qlog(`    GCD(${halfPower} - 1, ${n}) = ${factor1}`, 'info');
                                    qlog(`    GCD(${halfPower} + 1, ${n}) = ${factor2}`, 'info');
                                    
                                    if (factor1 > 1n && factor1 < n) {
                                        const cofactor = n / factor1;
                                        return {
                                            success: true,
                                            factor: factor1,
                                            cofactor: cofactor,
                                            quantumPath: a,
                                            period: period,
                                            visibility: visibility,
                                            method: 'quantum_shor_gcd1'
                                        };
                                    }
                                    
                                    if (factor2 > 1n && factor2 < n) {
                                        const cofactor = n / factor2;
                                        return {
                                            success: true,
                                            factor: factor2,
                                            cofactor: cofactor,
                                            quantumPath: a,
                                            period: period,
                                            visibility: visibility,
                                            method: 'quantum_shor_gcd2'
                                        };
                                    }
                                } else {
                                    qlog(`    Trivial case: a^(r/2) ‚â° ¬±1 (mod n)`, 'warning');
                                }
                            }
                        } catch (error) {
                            qlog(`    Error in standard approach: ${error.message}`, 'warning');
                        }
                    }
                    
                    // Method 2: Extended period analysis for odd periods or failed even periods
                    try {
                        // Check if a^r ‚â° 1 (mod n) for verification
                        if (quantumModExp(aBig, rBig, n) === 1n) {
                            qlog(`    Verified: ${aBig}^${period} ‚â° 1 (mod ${n})`, 'success');
                            
                            // Try different power fractions
                            const divisors = [3, 4, 6, 8, 9, 12];
                            for (const div of divisors) {
                                if (period % div === 0) {
                                    const fracPower = quantumModExp(aBig, rBig / BigInt(div), n);
                                    
                                    if (fracPower !== 1n && fracPower !== n - 1n) {
                                        const factor1 = quantumGcd(fracPower - 1n, n);
                                        const factor2 = quantumGcd(fracPower + 1n, n);
                                        
                                        qlog(`    Trying a^(r/${div}): ${aBig}^${period/div} ‚â° ${fracPower} (mod ${n})`, 'info');
                                        
                                        if (factor1 > 1n && factor1 < n) {
                                            const cofactor = n / factor1;
                                            qlog(`    üéä SUCCESS via fractional power!`, 'success');
                                            return {
                                                success: true,
                                                factor: factor1,
                                                cofactor: cofactor,
                                                quantumPath: a,
                                                period: period,
                                                visibility: visibility,
                                                method: `quantum_fractional_${div}`
                                            };
                                        }
                                        
                                        if (factor2 > 1n && factor2 < n) {
                                            const cofactor = n / factor2;
                                            qlog(`    üéä SUCCESS via fractional power!`, 'success');
                                            return {
                                                success: true,
                                                factor: factor2,
                                                cofactor: cofactor,
                                                quantumPath: a,
                                                period: period,
                                                visibility: visibility,
                                                method: `quantum_fractional_${div}`
                                            };
                                        }
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        qlog(`    Error in extended analysis: ${error.message}`, 'warning');
                    }
                    
                    // Method 3: Direct period-based factor search
                    try {
                        // Sometimes the period itself or its factors are useful
                        const periodFactors = [period, period/2, period/3, period/4, period/6, period/9];
                        for (const pf of periodFactors) {
                            if (Number.isInteger(pf) && pf > 1) {
                                const pfBig = BigInt(Math.floor(pf));
                                const testFactor = quantumGcd(pfBig, n);
                                
                                if (testFactor > 1n && testFactor < n) {
                                    const cofactor = n / testFactor;
                                    qlog(`    üéä SUCCESS via period factor analysis!`, 'success');
                                    qlog(`    ${n} = ${testFactor} √ó ${cofactor}`, 'success');
                                    qlog(`    Period factor: ${pf} ‚Üí GCD(${pfBig}, ${n}) = ${testFactor}`, 'info');
                                    return {
                                        success: true,
                                        factor: testFactor,
                                        cofactor: cofactor,
                                        quantumPath: a,
                                        period: period,
                                        visibility: visibility,
                                        method: 'quantum_period_factor'
                                    };
                                }
                            }
                        }
                    } catch (error) {
                        qlog(`    Error in period factor analysis: ${error.message}`, 'warning');
                    }
                }
            }
            
            const endTime = performance.now();
            qlog(`‚ùå Quantum factor extraction failed after testing ${Math.min(10, periodCandidates.length)} periods`, 'error');
            qlog(`‚è±Ô∏è Attempted extraction time: ${(endTime - startTime).toFixed(2)}ms`, 'warning');
            
            if (pureQuantumMode) {
                qlog(`‚öõÔ∏è PURE QUANTUM MODE: No classical fallbacks allowed`, 'quantum');
                return { success: false, reason: 'No factors found from pure quantum interference' };
            }
            
            // If quantum extraction fails, try the simple factorization as fallback (only in hybrid mode)
            qlog(`üîÑ Trying classical fallback factorization`, 'warning');
            const simpleFallback = simpleFactorization(n);
            if (simpleFallback.success) {
                qlog(`‚úÖ Classical fallback succeeded!`, 'success');
                return {
                    success: true,
                    factor: simpleFallback.factor,
                    cofactor: simpleFallback.cofactor,
                    quantumPath: 'classical_fallback',
                    period: 'N/A',
                    visibility: visibility,
                    method: 'classical_fallback_after_quantum'
                };
            }
            
            return { success: false, reason: 'No factors found from quantum interference or classical fallback' };
        }

        // Complete Triple-Slit Quantum Factorization
        async function tripleSlitQuantumFactorization(N, config) {
            if (isQuantumRunning) return;
            
            setQuantumRunning(true);
            const startTime = performance.now();
            
            try {
                const n = typeof N === 'bigint' ? N : BigInt(N);
                
                // Default configuration with proper object destructuring
                const defaultConfig = {
                    slitCount: 3,
                    timeSteps: 50000,
                    freqModes: 5,
                    phaseOffset: 0,
                    entanglement: 'strong',
                    coherenceLength: 1000,
                    decoherence: 0.01,
                    trialLimit: 1000000,
                    pureQuantumMode: false
                };
                
                const finalConfig = { ...defaultConfig, ...config };
                const {
                    slitCount,
                    timeSteps,
                    freqModes,
                    phaseOffset,
                    entanglement,
                    coherenceLength,
                    decoherence,
                    trialLimit,
                    pureQuantumMode
                } = finalConfig;
                
                qlog('üåü TRIPLE-SLIT QUANTUM FACTORIZATION INITIATED', 'quantum');
                qlog('N = ' + n, 'info');
                qlog('üìä Size: ' + n.toString(2).length + ' bits, ' + n.toString().length + ' digits', 'info');
                qlog('‚öõÔ∏è Quantum Configuration:', 'quantum');
                qlog('  ‚Ä¢ Slits: ' + slitCount, 'info');
                qlog('  ‚Ä¢ Time Steps: ' + timeSteps, 'info');
                qlog('  ‚Ä¢ Frequency Modes: ' + freqModes, 'info');
                qlog('  ‚Ä¢ Entanglement: ' + entanglement, 'info');
                qlog('  ‚Ä¢ Coherence Length: ' + coherenceLength, 'info');
                qlog('‚ïê'.repeat(80), 'quantum');
                
                // Step 1: Generate quantum wave function
                qlog(`\nüåä STEP 1: QUANTUM WAVE FUNCTION GENERATION`, 'quantum');
                const quantumData = generateTripleSlitWaveFunction(n, slitCount, timeSteps, freqModes, phaseOffset, entanglement);
                
                await new Promise(resolve => setTimeout(resolve, 100)); // Quantum decoherence simulation
                
                // Step 2: Analyze interference patterns
                qlog(`\nüîç STEP 2: INTERFERENCE PATTERN ANALYSIS`, 'interference');
                const interferenceAnalysis = analyzeTripleSlitInterference(quantumData, coherenceLength, decoherence, pureQuantumMode);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Step 3: Extract factors from quantum measurements
                qlog(`\nüéØ STEP 3: QUANTUM FACTOR EXTRACTION`, 'quantum');
                let factorResult = extractQuantumFactors(n, interferenceAnalysis, quantumData, pureQuantumMode);
                
                // If quantum extraction completely failed AND we're not in pure quantum mode, try emergency
                if (!factorResult.success && !pureQuantumMode) {
                    qlog(`üö® Quantum extraction failed - trying emergency factorization`, 'error');
                    
                    // Simple trial division as absolute last resort
                    const limit = Math.min(1000, Math.floor(Math.sqrt(Number(n))));
                    qlog(`  Emergency trial division up to ${limit}`, 'warning');
                    
                    for (let i = 2; i <= limit; i++) {
                        if (Number(n) % i === 0) {
                            const factor = BigInt(i);
                            const cofactor = n / factor;
                            
                            qlog(`  üÜò EMERGENCY SUCCESS: ${n} = ${factor} √ó ${cofactor}`, 'success');
                            
                            factorResult = {
                                success: true,
                                factor: factor,
                                cofactor: cofactor,
                                quantumPath: 'emergency_trial_division',
                                period: 'N/A',
                                visibility: interferenceAnalysis.visibility,
                                method: 'emergency_trial_division'
                            };
                            break;
                        }
                        
                        if (i % 50 === 0) {
                            qlog(`    Emergency testing ${i}...`, 'warning');
                        }
                    }
                } else if (!factorResult.success && pureQuantumMode) {
                    qlog(`‚öõÔ∏è PURE QUANTUM MODE: No classical fallbacks allowed - quantum factorization unsuccessful`, 'quantum');
                }
                
                // Step 4: Visualize quantum interference
                visualizeInterferencePattern(quantumData.interferencePattern);
                
                const totalTime = performance.now() - startTime;
                
                qlog('\n' + '‚ïê'.repeat(80), 'quantum');
                qlog('üéä QUANTUM FACTORIZATION COMPLETE', 'success');
                qlog('‚ïê'.repeat(80), 'quantum');
                
                if (factorResult.success) {
                    qlog(`‚úÖ SUCCESS: Quantum factorization achieved!`, 'success');
                    qlog(`üìä Quantum Statistics:`, 'quantum');
                    qlog(`  ‚Ä¢ Quantum Visibility: ${(interferenceAnalysis.visibility * 100).toFixed(2)}%`, 'info');
                    qlog(`  ‚Ä¢ Active Paths: ${quantumData.baseFreqs.length}`, 'info');
                    qlog(`  ‚Ä¢ Period Candidates: ${interferenceAnalysis.periodCandidates.length}`, 'info');
                    qlog(`  ‚Ä¢ Successful Path: a = ${factorResult.quantumPath}`, 'success');
                    qlog(`  ‚Ä¢ Quantum Period: r = ${factorResult.period}`, 'success');
                    qlog(`  ‚Ä¢ FACTORS FOUND: ${n} = ${factorResult.factor} √ó ${factorResult.cofactor}`, 'success');
                    qlog(`  ‚Ä¢ Factorization Method: ${factorResult.method}`, 'info');
                } else {
                    qlog(`‚ùå Quantum factorization unsuccessful`, 'error');
                    qlog(`üìä Quantum Diagnostics:`, 'warning');
                    qlog(`  ‚Ä¢ Visibility: ${(interferenceAnalysis.visibility * 100).toFixed(2)}%`, 'info');
                    qlog(`  ‚Ä¢ Period Candidates: ${interferenceAnalysis.periodCandidates.length}`, 'info');
                    qlog(`  ‚Ä¢ Decoherence: ${decoherence}`, 'info');
                }
                
                qlog(`‚è±Ô∏è Total quantum computation time: ${totalTime.toFixed(2)}ms`, 'info');
                
                // Store results
                const result = {
                    original: n.toString(),
                    success: factorResult.success,
                    factors: factorResult.success ? [factorResult.factor.toString(), factorResult.cofactor.toString()] : [],
                    quantumData: {
                        slitCount,
                        timeSteps,
                        freqModes,
                        entanglement,
                        visibility: interferenceAnalysis.visibility,
                        periodCandidates: interferenceAnalysis.periodCandidates.length,
                        quantumPath: factorResult.quantumPath?.toString(),
                        period: factorResult.period
                    },
                    time: totalTime,
                    timestamp: new Date().toISOString(),
                    method: 'triple_slit_quantum_interference'
                };
                
                quantumResults.push(result);
                return result;
                
            } catch (error) {
                qlog(`‚ùå QUANTUM ERROR: ${error.message}`, 'error');
                return { success: false, error: error.message };
            } finally {
                setQuantumRunning(false);
            }
        }

        // Visualize Interference Pattern
        function visualizeInterferencePattern(interferencePattern) {
            const canvas = document.getElementById('interferenceCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw interference pattern
            const maxIntensity = Math.max(...interferencePattern);
            const minIntensity = Math.min(...interferencePattern);
            const range = maxIntensity - minIntensity;
            
            for (let i = 0; i < interferencePattern.length && i < width; i++) {
                const intensity = (interferencePattern[i] - minIntensity) / range;
                const x = (i / interferencePattern.length) * width;
                
                // Create quantum interference visualization
                const r = Math.floor(138 + intensity * 117);  // Purple to bright
                const g = Math.floor(43 + intensity * 69);
                const b = Math.floor(226 - intensity * 100);
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(x, 0, 2, height * intensity);
                
                // Add quantum glow effect
                const alpha = intensity * 0.3;
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.fillRect(x - 2, 0, 6, height);
            }
            
            // Add quantum phase information
            ctx.strokeStyle = '#dda0dd';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            
            for (let i = 0; i < interferencePattern.length && i < width; i++) {
                const intensity = (interferencePattern[i] - minIntensity) / range;
                const x = (i / interferencePattern.length) * width;
                const y = height - (intensity * height);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            ctx.globalAlpha = 1.0;
            
            qlog(`üìä Interference pattern visualized: ${interferencePattern.length} data points`, 'quantum');
        }

        // Add simple factorization for small numbers
        function simpleFactorization(n) {
            n = typeof n === 'bigint' ? n : BigInt(n);
            
            qlog(`üîß SIMPLE FACTORIZATION: N = ${n}`, 'info');
            
            // Handle small cases
            if (n <= 1n) return { success: false, reason: 'Number too small' };
            if (n === 2n) return { success: false, reason: 'Prime number' };
            
            // Try small factors first
            const smallPrimes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n];
            
            for (const p of smallPrimes) {
                if (n % p === 0n) {
                    const cofactor = n / p;
                    qlog(`‚úÖ Simple factor found: ${n} = ${p} √ó ${cofactor}`, 'success');
                    return {
                        success: true,
                        factor: p,
                        cofactor: cofactor,
                        method: 'simple_trial_division'
                    };
                }
            }
            
            // Try a bit more exhaustive search for small numbers
            if (n < 10000n) {
                const limit = BigInt(Math.floor(Math.sqrt(Number(n)))) + 1n;
                for (let i = 2n; i <= limit; i++) {
                    if (n % i === 0n) {
                        const cofactor = n / i;
                        qlog(`‚úÖ Simple factor found: ${n} = ${i} √ó ${cofactor}`, 'success');
                        return {
                            success: true,
                            factor: i,
                            cofactor: cofactor,
                            method: 'exhaustive_trial_division'
                        };
                    }
                }
            }
            
            return { success: false, reason: 'No simple factors found' };
        }

        // Test Functions - Enhanced for debugging
        async function testBasicTripleSlit() {
            clearQuantumResults();
            qlog('üî¨ BASIC TRIPLE-SLIT TEST', 'quantum');
            qlog('Testing fundamental three-path quantum interference', 'info');
            
            const testNumber = 54n; // Your problematic case: 2 √ó 3¬≥
            qlog(`Testing problematic case: ${testNumber} = 2 √ó 27 = 2 √ó 3¬≥`, 'info');
            
            // First try simple factorization
            const simple = simpleFactorization(testNumber);
            if (simple.success) {
                qlog(`Simple factorization succeeded: ${testNumber} = ${simple.factor} √ó ${simple.cofactor}`, 'success');
                return;
            }
            
            await tripleSlitQuantumFactorization(testNumber, {
                slitCount: 3,
                timeSteps: 5000,
                freqModes: 3,
                entanglement: 'weak',
                coherenceLength: 500,
                decoherence: 0.005
            });
        }

        async function testEnhancedInterference() {
            clearQuantumResults();
            qlog('üåä ENHANCED INTERFERENCE TEST', 'interference');
            qlog('Testing 989789 = 557 √ó 1777 (known semi-prime)', 'info');
            
            const testNumber = 989789n;
            await tripleSlitQuantumFactorization(testNumber, {
                slitCount: 4,
                timeSteps: 20000,
                freqModes: 7,
                entanglement: 'strong',
                coherenceLength: 2000,
                decoherence: 0.005
            });
        }

        async function testPureQuantum() {
            clearQuantumResults();
            qlog('‚öõÔ∏è PURE QUANTUM MODE TEST', 'quantum');
            qlog('Testing pure quantum interference without any fallbacks', 'info');
            
            const testNumber = 143n; // 11 √ó 13 - good test case
            await tripleSlitQuantumFactorization(testNumber, {
                slitCount: 3,
                timeSteps: 30000,
                freqModes: 8,
                entanglement: 'strong',
                coherenceLength: 3000,
                decoherence: 0.001,
                pureQuantumMode: true  // PURE QUANTUM ONLY
            });
        }

        async function testQuantumEntanglement() {
            clearQuantumResults();
            qlog('‚öõÔ∏è QUANTUM ENTANGLEMENT TEST', 'quantum');
            qlog('Testing correlated slit measurements with fallbacks', 'info');
            
            const testNumber = 323n; // 17 √ó 19
            await tripleSlitQuantumFactorization(testNumber, {
                slitCount: 3,
                timeSteps: 30000,
                freqModes: 5,
                entanglement: 'strong',
                phaseOffset: Math.PI / 4,
                decoherence: 0.005,
                pureQuantumMode: false  // Hybrid mode
            });
        }

        async function testLargeNumber() {
            clearQuantumResults();
            qlog('üéØ LARGE NUMBER QUANTUM TEST', 'quantum');
            qlog('Testing 80-bit quantum factorization', 'info');
            
            const testNumber = 1208925819614629174706176n;
            await tripleSlitQuantumFactorization(testNumber, {
                slitCount: 5,
                timeSteps: 100000,
                freqModes: 10,
                entanglement: 'strong',
                coherenceLength: 5000,
                decoherence: 0.001
            });
        }

        async function testPhaseCorrelation() {
            clearQuantumResults();
            qlog('üîÑ PHASE CORRELATION TEST', 'interference');
            qlog('Testing three-way phase relationships', 'info');
            
            const testNumber = 899n; // 29 √ó 31
            await tripleSlitQuantumFactorization(testNumber, {
                slitCount: 4,
                timeSteps: 40000,
                freqModes: 8,
                entanglement: 'strong',
                phaseOffset: Math.PI / 3,
                coherenceLength: 3000
            });
        }

        async function testCoherenceAnalysis() {
            clearQuantumResults();
            qlog('üåå COHERENCE ANALYSIS TEST', 'quantum');
            qlog('Testing quantum coherence measurements', 'info');
            
            const testNumber = 2021n; // 43 √ó 47
            await tripleSlitQuantumFactorization(testNumber, {
                slitCount: 6,
                timeSteps: 60000,
                freqModes: 12,
                entanglement: 'strong',
                coherenceLength: 8000,
                decoherence: 0.0005
            });
        }

        async function testCustomQuantum() {
            const number = document.getElementById('quantumNumber').value.trim();
            const trialLimit = parseInt(document.getElementById('trialLimit').value) || 1000000;
            const slitCount = parseInt(document.getElementById('slitCount').value) || 3;
            const timeSteps = parseInt(document.getElementById('timeSteps').value) || 50000;
            const freqModes = parseInt(document.getElementById('freqModes').value) || 5;
            const coherenceLength = parseInt(document.getElementById('coherenceLength').value) || 1000;
            const phaseOffset = parseFloat(document.getElementById('phaseOffset').value) || 0;
            const entanglement = document.getElementById('entanglement').value || 'strong';
            const decoherence = parseFloat(document.getElementById('decoherence').value) || 0.01;
            
            if (!number) {
                qlog('‚ùå Please enter a number to factor', 'error');
                return;
            }
            
            if (!/^\d+$/.test(number)) {
                qlog('‚ùå Please enter a valid positive integer', 'error');
                return;
            }
            
            // Validate quantum parameters
            if (slitCount < 2 || slitCount > 7) {
                qlog('‚ùå Slit count must be between 2 and 7', 'error');
                return;
            }
            
            if (timeSteps < 1000 || timeSteps > 500000) {
                qlog('‚ùå Time steps must be between 1,000 and 500,000', 'error');
                return;
            }
            
            try {
                const n = BigInt(number);
                if (n <= 1n) {
                    qlog('‚ùå Please enter a number greater than 1', 'error');
                    return;
                }
                
                clearQuantumResults();
                qlog(`üîß CUSTOM QUANTUM FACTORIZATION`, 'quantum');
                qlog(`Input: ${n}`, 'info');
                qlog(`Size: ${n.toString(2).length} bits, ${n.toString().length} digits`, 'info');
                
                await tripleSlitQuantumFactorization(n, {
                    slitCount,
                    timeSteps,
                    freqModes,
                    coherenceLength,
                    phaseOffset,
                    entanglement,
                    decoherence,
                    trialLimit
                });
                
            } catch (error) {
                qlog(`‚ùå Error parsing number: ${error.message}`, 'error');
            }
        }

        // Download Functions
        function downloadQuantumData() {
            const data = {
                session_info: {
                    start_time: quantumSession.toISOString(),
                    end_time: new Date().toISOString(),
                    session_duration: Date.now() - quantumSession.getTime(),
                    algorithm_version: 'Triple-Slit Quantum Factoring v1.0',
                    quantum_paradigm: 'triple_slit_interference'
                },
                quantum_results: quantumResults,
                quantum_log: quantumLog
            };
            
            download(JSON.stringify(data, null, 2), `quantum_factoring_data_${timestamp()}.json`, 'application/json');
            qlog('üì• Quantum data downloaded', 'success');
        }

        function downloadInterference() {
            const canvas = document.getElementById('interferenceCanvas');
            const link = document.createElement('a');
            link.download = `interference_pattern_${timestamp()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            qlog('üì• Interference pattern downloaded', 'success');
        }

        function downloadPhaseData() {
            let report = 'üåä QUANTUM PHASE ANALYSIS REPORT\n';
            report += '‚ïê'.repeat(60) + '\n';
            report += `Generated: ${new Date().toISOString()}\n`;
            report += `Quantum Paradigm: Triple-Slit Interference\n\n`;
            
            quantumResults.forEach((result, index) => {
                report += `\nQuantum Test ${index + 1}:\n`;
                report += `Number: ${result.original}\n`;
                report += `Success: ${result.success}\n`;
                if (result.success) {
                    report += `Factors: ${result.factors.join(' √ó ')}\n`;
                }
                report += `Quantum Configuration:\n`;
                report += `  Slits: ${result.quantumData.slitCount}\n`;
                report += `  Time Steps: ${result.quantumData.timeSteps}\n`;
                report += `  Visibility: ${(result.quantumData.visibility * 100).toFixed(2)}%\n`;
                report += `  Period Candidates: ${result.quantumData.periodCandidates}\n`;
                report += `  Time: ${result.time.toFixed(2)}ms\n`;
            });
            
            download(report, `quantum_phase_analysis_${timestamp()}.txt`, 'text/plain');
            qlog('üì• Phase analysis downloaded', 'success');
        }

        function downloadQuantumLog() {
            let report = 'üìù QUANTUM SESSION LOG\n';
            report += '‚ïê'.repeat(60) + '\n';
            report += `Session: ${quantumSession.toISOString()}\n`;
            report += `Quantum Entries: ${quantumLog.length}\n`;
            report += `Paradigm: Triple-Slit Interference\n\n`;
            
            quantumLog.forEach(entry => {
                const relativeTime = (entry.sessionTime / 1000).toFixed(3);
                report += `[${entry.localTime}] (+${relativeTime}s) [${entry.type.toUpperCase()}] ${entry.message}\n`;
            });
            
            download(report, `quantum_session_log_${timestamp()}.txt`, 'text/plain');
            qlog('üì• Quantum log downloaded', 'success');
        }

        function download(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function timestamp() {
            return new Date().toISOString().slice(0,19).replace(/:/g,'-');
        }

        // Initialize Quantum System
        window.addEventListener('load', () => {
            quantumSession = new Date();
            qlog('üåü Triple-Slit Quantum Factoring System Initialized', 'quantum');
            qlog('‚öõÔ∏è Quantum superposition state prepared', 'quantum');
            qlog('üåä Triple-slit interference chamber calibrated', 'interference');
            qlog('üî¨ Ready for quantum measurements!', 'success');
            qlog('', 'info');
            qlog('Quantum Principles:', 'quantum');
            qlog('‚Ä¢ Wave-particle duality reveals factor structure', 'info');
            qlog('‚Ä¢ Triple-slit creates richer interference than double-slit', 'info');
            qlog('‚Ä¢ Quantum entanglement correlates measurement outcomes', 'info');
            qlog('‚Ä¢ Phase relationships encode mathematical structure', 'info');
            qlog('‚Ä¢ Coherence length determines measurement precision', 'info');
            qlog('‚Ä¢ Pure Quantum Mode: No classical fallbacks allowed', 'quantum');
            
            // Initialize interference pattern visualization
            const canvas = document.getElementById('interferenceCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw initial quantum wave pattern
                ctx.strokeStyle = '#9370db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = 0; x < canvas.width; x += 2) {
                    const y = canvas.height/2 + 30 * Math.sin(x * 0.02) * Math.cos(x * 0.015) * Math.sin(x * 0.008);
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('quantumNumber').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') testCustomQuantum();
            });
        });
    </script>
</body>
</html>